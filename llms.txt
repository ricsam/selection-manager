# SelectionManager Library - API Reference

React library for grid-based cell selections with mouse/keyboard interactions, supporting finite and infinite grids.

## Core Types

```typescript
type SMSelection = {
  start: { row: number; col: number };
  end: { row: number; col: number };
};

type IsSelecting = 
  | { type: "none" }
  | (SMSelection & { type: "drag" | "add" | "remove" | "shift" });

type IsEditing =
  | { type: "none" }
  | { type: "cell"; row: number; col: number };

type IsHovering =
  | { type: "none" }
  | { type: "cell"; row: number; col: number }
  | { type: "group"; group: SMArea }
  | { type: "header"; index: number; headerType: "row" | "col" };

type SelectionManagerState = {
  hasFocus: boolean;
  selections: SMSelection[];
  isSelecting: IsSelecting;
  isEditing: IsEditing;
  isHovering: IsHovering;
};
```

## SelectionManager Class

### Constructor
```typescript
new SelectionManager(
  getNumRows: () => number,    // Can return Infinity
  getNumCols: () => number,    // Can return Infinity
  getGroups: () => SMArea[]    // Returns merged/grouped cell areas
)
```

### State Management
```typescript
getState(): SelectionManagerState
setState(state: Partial<SelectionManagerState> | ((state: SelectionManagerState) => Partial<SelectionManagerState>)): void

onNextState(callback: (state: SelectionManagerState) => void): () => void  // Uncontrolled mode
onNewRequestedState(callback: (state: SelectionManagerState) => void): () => void  // Controlled mode
observeStateChange<T>(selector: (state: SelectionManagerState) => T, callback: (value: T) => void | (() => void), runInstant?: boolean): () => void
```

### Mouse Events
```typescript
cellMouseDown(row: number, col: number, keys: { shiftKey: boolean; ctrlKey: boolean; metaKey: boolean }): void
cellMouseEnter(row: number, col: number): void
cellDoubleClick(row: number, col: number): void
headerMouseDown(index: number, type: "row" | "col", keys: { shiftKey: boolean; ctrlKey: boolean; metaKey: boolean }): void
headerMouseEnter(index: number, type: "row" | "col"): void
mouseUp(): void
```

### Keyboard
```typescript
handleKeyDown(event: KeyboardEvent): void
```

**Shortcuts:** Escape (cancel/clear), F2 (edit), Ctrl/Cmd+A (select all), Ctrl/Cmd+C/X (copy/cut), Delete/Backspace (delete), Arrow keys (navigate), Shift+Arrow (extend), Ctrl+Shift+Arrow (extend to edge). All disabled while editing except Escape and F2.

### Selection Queries
```typescript
isSelected(cell: { row: number; col: number }): boolean
isHoveringCell(row: number, col: number): boolean
isWholeRowSelected(index: number): boolean
isWholeColSelected(index: number): boolean
hasSelection(): boolean
isAllSelected(): boolean
cellInSelection(cell: { row: number; col: number }, selection: SMSelection): boolean
getTopLeftCellInSelection(): { row: number; col: number } | undefined
getSelectionsBoundingRect(): SMSelection | undefined
getNonOverlappingSelections(): SMSelection[]
forEachSelectedCell(callback: (cell: { source: { row: number; col: number }; target: { row: number; col: number } }) => void): void
```

### Group/Merged Cell Operations
```typescript
findGroupContainingCell(cell: { row: number; col: number }): SMArea | undefined
isHoveringGroup(group: SMArea): boolean
getBoxShadow(options?: { color?: string; position?: ("top" | "right" | "bottom" | "left" | "all")[] }): string
```

### Visual Styling
```typescript
getCellBoxShadow(cell: { row: number; col: number }): string | undefined
getHeaderBoxShadow(index: number, type: "row" | "col"): string | undefined
getContainerBoxShadow(): string | undefined
selectionBorders(cell: { row: number; col: number }): Border[]
currentSelectionBorders(cell: { row: number; col: number }): Border[]

type Border = "left" | "right" | "top" | "bottom"
```

**Border Colors:** Blue (#2196F3) for committed selections, Gray (#c5b4b3) for current selection, Green (#9ec299) for active headers, Brown (#c5b4b3) for hovered cells/headers.

### Cell Editing
```typescript
cellDoubleClick(row: number, col: number): void  // Start editing
cancelEditing(): void
isEditingCell(row: number, col: number): boolean
saveCellValue(cell: { rowIndex: number; colIndex: number }, value: string): void  // Save and trigger listenToInsertData
```

**Best Practices for Cell Editing:**
1. Use `defaultValue` (not `value`) for input elements to avoid React warnings and improve performance
2. Always add `onBlur` handler to cancel editing when user clicks away
3. Use `saveCellValue()` on Enter key - this automatically triggers all `listenToInsertData` listeners
4. Handle both Enter (save) and Escape (cancel) keys for standard spreadsheet behavior

### Data Operations
```typescript
selectionToTsv(data: Map<string, unknown>): string  // Keys format: "row,col"
listenToCopy(callback: (isCut: boolean) => void): () => void
listenToDelete(callback: () => void): () => void
listenToInsertData(callback: (data: Array<{ rowIndex: number; colIndex: number; value: string }>) => void): () => void
```

## Utility Functions

```typescript
type CellData = {
  rowIndex: number;
  colIndex: number; 
  value: string;
};

parseCSVContent(content: string): CellData[]
writeToClipboard(data: string): void
```

**parseCSVContent Features:**
- Auto-detects delimiters (tabs > commas > spaces)
- Handles quoted CSV fields properly
- Treats formatted numbers (1,234.56) as single values, not CSV
- Preserves original row/column structure
- Special handling for space-separated numbers

**writeToClipboard Features:**
- Uses modern navigator.clipboard API when available
- Automatic fallback for older browsers
- Error handling for clipboard access failures

### DOM Setup (High Performance)
```typescript
setupCellElement(el: HTMLElement, cell: { row: number; col: number }): () => void
setupHeaderElement(el: HTMLElement, index: number, type: "row" | "col"): () => void
setupContainerElement(el: HTMLElement): () => void
```

Automatically handles event listeners, styling updates, and state synchronization. Returns cleanup functions.

### Focus Management
```typescript
focus(): void
blur(): void
cancelSelection(): void
cancelHovering(): void
```

## React Hooks

### useInitializeSelectionManager
```typescript
function useInitializeSelectionManager(props: {
  getNumRows?: () => number;                              // Default: () => Infinity
  getNumCols?: () => number;                              // Default: () => Infinity
  getGroups?: () => SMArea[];                             // Default: () => []
  initialState?: Partial<SelectionManagerState>;         // Uncontrolled mode
  state?: SelectionManagerState;                          // Controlled mode
  onStateChange?: (state: SelectionManagerState) => void;
  containerElement?: HTMLElement | null;                 // Auto event handling
}): SelectionManager
```

### useSelectionManager
```typescript
function useSelectionManager<T>(
  selectionManager: SelectionManager,
  selector: () => T,
  areEqual?: (a: T, b: T) => boolean
): T
```

## Usage Examples

### Basic Setup
```typescript
const selectionManager = useInitializeSelectionManager({
  getNumRows: () => 10,
  getNumCols: () => 5,
  containerElement: containerRef
});

const selections = useSelectionManager(selectionManager, () => selectionManager.getState().selections);
```

### Manual Events (React Hooks Approach)
```typescript
<div
  onMouseDown={(e) => selectionManager.cellMouseDown(row, col, e)}
  onMouseEnter={() => selectionManager.cellMouseEnter(row, col)}
  style={{ boxShadow: selectionManager.getCellBoxShadow({ row, col }) }}
/>
```

### Auto Events (DOM Setup Approach)
```typescript
const CellComponent = React.memo(({ row, col, selectionManager }) => {
  const cellRef = useCallback((el) => {
    if (el) return selectionManager.setupCellElement(el, { row, col });
  }, [row, col, selectionManager]);
  return <div ref={cellRef} />;
});
```

### Cell Editing Pattern
```typescript
const EditableCell = ({ row, col, selectionManager, initialValue }) => {
  const isEditing = useSelectionManager(selectionManager, () => 
    selectionManager.isEditingCell(row, col)
  );

  if (isEditing) {
    return (
      <input
        autoFocus
        defaultValue={initialValue}  // Use defaultValue, NOT value
        onBlur={() => selectionManager.cancelEditing()}  // Always cancel on blur
        onKeyDown={(e) => {
          if (e.key === 'Enter') {
            // Save using saveCellValue - triggers listenToInsertData listeners!
            selectionManager.saveCellValue(
              { rowIndex: row, colIndex: col },
              e.target.value
            );
            selectionManager.cancelEditing();
          } else if (e.key === 'Escape') {
            selectionManager.cancelEditing();
          }
        }}
      />
    );
  }
  
  return <div>{initialValue}</div>;
};
```

### Data Operations
```typescript
// Copy
selectionManager.listenToCopy((isCut) => {
  const boundingRect = selectionManager.getSelectionsBoundingRect();
  const grid = Array(height).fill(null).map(() => Array(width).fill(""));
  selectionManager.forEachSelectedCell(({ source, target }) => {
    grid[target.row][target.col] = data.get(`${source.row},${source.col}`);
  });
  const tsv = grid.map(row => row.join('\t')).join('\n');
  navigator.clipboard.writeText(tsv);
});

// Delete
selectionManager.listenToDelete(() => {
  selectionManager.getNonOverlappingSelections().forEach(selection => {
    for (let row = selection.start.row; row <= selection.end.row; row++) {
      for (let col = selection.start.col; col <= selection.end.col; col++) {
        data.delete(`${row},${col}`);
      }
    }
  });
});

// Paste or drag and drop
selectionManager.listenToInsertData((insertData) => {
  insertData.forEach(({ rowIndex, colIndex, value }) => {
    data.set(`${rowIndex},${colIndex}`, value);
  });
});

// Custom CSV import using utility functions
import { parseCSVContent, writeToClipboard } from 'selection-manager';

const importCsvData = (csvText: string) => {
  const cellData = parseCSVContent(csvText);
  const topLeft = selectionManager.getTopLeftCellInSelection() || { row: 0, col: 0 };
  
  cellData.forEach(({ rowIndex, colIndex, value }) => {
    const targetRow = topLeft.row + rowIndex;
    const targetCol = topLeft.col + colIndex;
    data.set(`${targetRow},${targetCol}`, value);
  });
};

// Custom export with clipboard
const exportSelection = () => {
  const tsv = selectionManager.selectionToTsv(data);
  writeToClipboard(tsv);
};
```

**⚠️ Performance Caveat**: Each cell/header MUST be its own component to get memoized callback refs. If you create callback refs in a loop or render function, they will be recreated on every render, causing constant cleanup/setup cycles and poor performance.

## Key Behaviors

### Selection Types
- **drag**: Normal click-and-drag selection
- **add**: Ctrl/Cmd+click to add to existing selections  
- **remove**: Ctrl/Cmd+click on selected area to remove from selection
- **shift**: Shift+click to extend last selection

### Copy/Paste/Delete Operations
- **Copy (Ctrl/Cmd+C)**: Uses `getSelectionsBoundingRect()` and `getNonOverlappingSelections()` to create TSV grid
- **Cut (Ctrl/Cmd+X)**: Same as copy but with cut flag set to true
- **Delete (Delete/Backspace)**: Clears selected cells using `getNonOverlappingSelections()`
- **Paste (Ctrl/Cmd+V)**: Automatically parses CSV/TSV from clipboard starting at top-left selection
- **File Drop**: Supports dropping CSV/TSV files to paste data

### Selection Analysis
- **`getSelectionsBoundingRect()`**: Returns smallest rectangle containing all selections
- **`getNonOverlappingSelections()`**: Decomposes overlapping selections into distinct regions
- **`forEachSelectedCell(callback)`**: Iterates through all selected cells with source/target coordinates
- Useful for data operations that need to handle complex multi-selection scenarios

### Infinite Grid Support
- Use `Infinity` as return value from `getNumRows()`/`getNumCols()`
- Selections can have `Infinity` as end coordinates
- Visual borders handle infinite ranges appropriately

### Border Colors
- **Blue (#2196F3)**: Committed selections
- **Gray (#c5b4b3)**: Current selection being made
- **Green (#9ec299)**: Active row/column headers
- **Brown (#c5b4b3)**: Hovered cells and headers

### Multi-Selection
- Hold Ctrl/Cmd while clicking to add/remove selections
- Hold Shift while clicking to extend last selection
- Supports complex selection unions and subtractions

### Whole Row/Column Detection
- `isWholeRowSelected()`/`isWholeColSelected()` detect when union of selections covers entire row/column
- Works with both finite and infinite grids
- Handles overlapping selections correctly

### All Cells Selection Detection
- `isAllSelected()` checks if union of selections covers all table cells

### Merged Cell Groups
- Use `getGroups()` callback to define merged/grouped cell areas
- Groups are `SMArea` objects with same structure as selections
- Groups are automatically detected during hover
- `findGroupContainingCell()` returns the group containing a specific cell
- `isHoveringGroup(group)` checks if currently hovering over a group
- `getBoxShadow()` provides customizable styling for groups
- Common pattern: hide non-top-left cells in groups, use CSS Grid to span multiple cells
